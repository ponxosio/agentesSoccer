%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage{listings}
\usepackage{subcaption}
\usepackage{graphicx}
\graphicspath{{/home/angel/Documentos/universidad/practicas/vision/practica3/memoria/capturas/}}

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[spanish]{babel}
\selectlanguage{spanish}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amsthm} % Math packages

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
% COLOR FOR LSTLISTING
%----------------------------------------------------------------------------------------
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{UPM Visión por computador} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Práctica 3: Visión estéreo  \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Ángel Panizo LLedot} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------
\lstset{language=Python} 

\section{Reconstrucción}
\subsection{Ejercicio 1}

Para calcular los puntos en 3D que corresponden a los puntos 2D, recibidos como entrada, habrá que resolver para cada punto el sistema de ecuaciones siguiente, que usa las matrices de proyección de ambas cámaras. Para la cámara uno:

\begin{equation}
\begin{bmatrix}
 	\lambda j\\
 	\lambda i\\
	\lambda
\end{bmatrix}
=
\begin{bmatrix}
	P1_{11}& P1_{12}& P1_{13}& P1_{14}\\
	P1_{21}& P1_{22}& P1_{23}& P1_{24}\\
	P1_{31}& P1_{32}& P1_{33}& P1_{34}\\
\end{bmatrix}
*
\begin{bmatrix}
 	X\\
 	Y\\
 	Z\\
 	1\\
\end{bmatrix}
\end{equation} 

\begin{equation}
	\left.
	\begin{array}{l}
		\lambda*i = P1_{11}*X + P1_{12}*Y + P1_{13}*Z + P1_{14} \\
		\lambda*j = P1_{21}*X + P1_{22}*Y + P1_{23}*Z + P1_{24} \\
		\lambda = P1_{31}*X + P1_{32}*Y + P1_{33}*Z + P1_{34} \\		
	\end{array}
	\right\rbrace
\end{equation} 

\begin{equation}
	\left.
	\begin{array}{l}
		(P1_{31}*X + P1_{32}*Y + P1_{33}*Z + P1_{34})*i = P1_{11}*X + P1_{12}*Y + P1_{13}*Z + P1_{14} \\
		(P1_{31}*X + P1_{32}*Y + P1_{33}*Z + P1_{34})*j = P1_{21}*X + P1_{22}*Y + P1_{23}*Z + P1_{24} \\
	\end{array}
	\right\rbrace
\end{equation} 

\begin{equation}
	\left.
	\begin{array}{l}
		(P1_{11} - P1_{31}*i)*X + (P1_{12} - P1_{32}*i)*Y + (P1_{13} - P1_{33}*i)*Z = -(P1_{14} - P1_{34}*i) \\
		(P1_{21} - P1_{31}*j)*X + (P1_{22} - P1_{32}*j)*Y + (P1_{23} - P1_{33}*j)*Z = -(P1_{24} - P1_{34}*j) \\
	\end{array}
	\right\rbrace
\end{equation} 

el proceso es el mismo para la otra cámara, dando como resultado el sistema de ecuaciones siguiente:

\begin{equation}
	\left.
	\begin{array}{l}
		(P1_{11} - P1_{31}*i_1)*X + (P1_{12} - P1_{32}*i_1)*Y + (P1_{13} - P1_{33}*i_1)*Z = -(P1_{14} - P1_{34}*i_1) \\
		(P1_{21} - P1_{31}*j_1)*X + (P1_{22} - P1_{32}*j_1)*Y + (P1_{23} - P1_{33}*j_1)*Z = -(P1_{24} - P1_{34}*j_1) \\
		(P2_{11} - P2_{31}*i_2)*X + (P2_{12} - P2_{32}*i_2)*Y + (P2_{13} - P2_{33}*i_2)*Z = -(P2_{14} - P2_{34}*i_2) \\
		(P2_{21} - P2_{31}*j_2)*X + (P2_{22} - P2_{32}*j_2)*Y + (P2_{23} - P2_{33}*j_2)*Z = -(P2_{24} - P2_{34}*j_2) \\
	\end{array}
	\right\rbrace
\end{equation} 

Que resolveremos por mínimos cuadrados, siendo las matrices $A$,  $b$, $x$ como sigue:

\begin{equation}
	\begin{array}{l}
		A = \begin{bmatrix}
				(P1_{11} - P1_{31}*i_1) & (P1_{12} - P1_{32}*i_1) & (P1_{13} - P1_{33}*i_1)\\
				(P1_{21} - P1_{31}*j_1) & (P1_{22} - P1_{32}*j_1) & (P1_{23} - P1_{33}*j_1)\\
				(P2_{11} - P2_{31}*i_2) & (P2_{12} - P2_{32}*i_2) & (P2_{13} - P2_{33}*i_2)\\
				(P2_{21} - P2_{31}*j_2) & (P2_{22} - P2_{32}*j_2) & (P2_{23} - P2_{33}*j_2)\\
			\end{bmatrix}\\
		b = \begin{bmatrix}
				-(P1_{14} - P1_{34}*i_1) \\
				-(P1_{24} - P1_{34}*j_1) \\
				-(P2_{14} - P2_{34}*i_2) \\
				-(P2_{24} - P2_{34}*j_2) \\
			\end{bmatrix}\\
		x = \begin{bmatrix}
				X\\
				Y\\
				Z\\
			\end{bmatrix}\\
	\end{array}
\end{equation} 

Dando como resultado:

\begin{equation}
	\begin{array}{l}
		x = (A^t*A)^{-1}*A^t*b
	\end{array}
\end{equation} 

\subsection{Ejercicio 2}
En la figura 1.1 se muestran los puntos seleccionados y la reconstrucción en 3D:\\

\begin{figure}
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{puntos}
  \caption{puntos seleccionados}
  \label{fig:sfig1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.82\linewidth]{reconstruccion}
  \caption{salida de la reconstruccion 3D}
  \label{fig:sfig2}
\end{subfigure}
\caption{capturas de las salida del ejercicio 2}
\label{fig:fig}
\end{figure}  

\subsection{Ejercicio 3}
Para reproyectar los puntos 3D, calculados en el ejerció anterior, en las imágenes de nuevo seguiremos la siguiente ecuación ya conocida:

\begin{equation}
\begin{bmatrix}
 	\lambda j\\
 	\lambda i\\
	\lambda
\end{bmatrix}
=
P
*
\begin{bmatrix}
 	X\\
 	Y\\
 	Z\\
 	1\\
\end{bmatrix}
\end{equation} 

En la figura 1.2 se muestran unas capturas con los resultados.\\

\begin{figure}
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{puntos_re}
  \caption{puntos seleccionados}
  \label{fig:sfig1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{reconstruccion2D}
  \caption{salida de la reconstruccion a 2D}
  \label{fig:sfig2}
\end{subfigure}
\caption{capturas de las salida del ejercicio 3}
\label{fig:fig}
\end{figure}  

\clearpage

\section{Geometría epipolar}
\subsection{Ejercicio 4}

Se nos pide calcular la matriz fundamental $F$, para ello la matriz fundamental se define, según los apuntes, como sigue:

\begin{equation}
	F = B^{-t} * [B^{-1}*\vec{d} - A^{-1}*\vec{b}]_{x} * A^{-1}
\end{equation}

donde: $B$, $\vec{d}$, $A$ y $\vec{b}$ se obtienen de las matrices de calibración de la cámara 1 y 2 como sigue:

Sea $P_1$ la matriz de calibración de la cámara uno y $P_2$ la de la cámara dos, entonces:

\begin{equation}
	\begin{array}{l}
		P_1 = [A | \vec{b}] \\
		P_2 = [B | \vec{d}]	\\
	\end{array} 
\end{equation}

Y el operador $[]_x$ la matriz producto vectorial, que se calcula como sigue:

\begin{equation}
	[b]_x = \begin{bmatrix}
 				0 & b_3 & -b_2\\
 				-b_3 & 0 & b_1\\
 				b_2 & -b_1 0\\
			\end{bmatrix}
\end{equation}

A continuación la función implementada en python que calcula la matriz fundamental a partir de las matrices de proyección:

\begin{lstlisting}
def projmat2f(P1, P2):
    """
        Calcula la matriz fundamental a partir de las matrices de proyecion de las 
        dos camaras, usando el metodo que se indica en la memoria.
    :param P1: matriz de proyecion de 3x4 de la camara uno
    :param P2: matriz de proyecion de 3x4 de la camara dos
    :return: matriz fundamental de 3x3
    """
    # extraigo las submatrices de P1 y P2 que se usaran en los claculos de la matriz 
    # fundamental
    A = P1[0:3, 0:3]
    b = P1[:, 3]
    B = P2[0:3, 0:3]
    d = P2[:, 3]

    # calculo la matriz, para hacer el producto vectorial
    matrizPVectorial = np.dot(np.linalg.inv(B), d) - np.dot(np.linalg.inv(A), b)

    # constuyo la matriz producto vectorial
    matrizPVectorial = np.array([[0, matrizPVectorial[2], -matrizPVectorial[1]],
                                 [-matrizPVectorial[2], 0, matrizPVectorial[0]],
                                 [matrizPVectorial[1], -matrizPVectorial[0], 0]])

    # Calculo la matriz fundamental: B^-t * matrizPVectorial * A^-1
    #   B^-t * matrizPVectorial
    F = np.dot(np.linalg.inv(B).transpose(), matrizPVectorial)
    # (B^-t * matrizPVectorial) * A^-1
    F = np.dot(F, np.linalg.inv(A))
    return F
\end{lstlisting}

La matriz fundamental calculada a partir de las matrices de proyección que se adjuntan con la práctica es la siguiente:

\begin{equation}
	\begin{bmatrix}
		-8.37918051e-09  &  2.64352488e-06 & -8.61307712e-04 \\
		-8.17120601e-06  & -4.36740640e-06 & -1.37641120e-01 \\
 		2.27541839e-03   & 1.42176580e-01  & -7.61491838e-03 \\
	\end{bmatrix}
\end{equation}

\subsection{Ejercicio 7}

Como se indica en el enunciado se puede calcular la recta epipolar $l_2$, donde se encontrará el punto homólogo a un punto $m_1$ de la imagen 1, de la siguiente forma:

\begin{equation}
	l_2 = F * m_1
\end{equation}

Para pintar la linea en la imagen se buscarán los puntos del borde de la imagen que sean homólogos a $l_2$. Un punto $m_2$ será homologo a $l_2$ si:

\begin{equation}
	m_2^t * l_2 = 0
\end{equation}

En el código se considera que un valor menor que $0.01$ es cero.
Una vez encontrados los puntos de corte con los bordes se pinta la linea entre ellos.

\subsection{Ejercicio 8}

En la figura 2.1 se muestran las lineas epipolares de los puntos seleccionados, para las dos imágenes.\\
Para el caso $a$ se usó la matriz fundamental $F$:

\begin{equation}
	F =
	\begin{bmatrix}
		-8.37918051e-09  &  2.64352488e-06 & -8.61307712e-04 \\
		-8.17120601e-06  & -4.36740640e-06 & -1.37641120e-01 \\
 		2.27541839e-03   & 1.42176580e-01  & -7.61491838e-03 \\
	\end{bmatrix}
\end{equation}

Para el caso $b$ se usó la matriz fundamental $F'$

\begin{equation}
	F'=
	\begin{bmatrix}
		-8.37918051e-09 & -8.17120601e-06 & 2.27541839e-03 \\
		2.64352488e-06  & -4.36740640e-06 & 1.42176580e-01 \\
		-8.61307712e-04 & -1.37641120e-01 & -7.61491838e-03 \\
	\end{bmatrix}
\end{equation}

\begin{figure}
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{epipolares}
  \caption{puntos seleccionados y lineas epipolares}
  \label{fig:sfig1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{epipolares2}
  \caption{puntos seleccionados y lineas epipolares}
  \label{fig:sfig2}
\end{subfigure}
\caption{capturas de las salida del ejercicio 8}
\label{fig:fig}
\end{figure}

\newpage

\section{Búsqueda de correspondencia}
\subsection{Ejercicio 10}

A continuación el código para ejecutar el ejercicio 10:

\begin{lstlisting}
def ejercicio10(imagen1, imagen2, P1, P2):
    print("Ejecutando ejercio10:")
    print("Rectificando imagenes...")
    img1G = misc.rgb2gray(imagen1/255.0)
    img2G = misc.rgb2gray(imagen2/255.0)

    F = projmat2f(P1, P2)
    H1, H2 = misc.projmat2rectify(P1, P2, img1G.shape)
    imagen1Rec, imagen2Rec = misc.rectify_images(img1G, img2G, H1, H2)

    print("pintando lineas epipolares...")
    plot_epipolar_lines(imagen1Rec, imagen2Rec, F)
\end{lstlisting}

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{epipolares_correccion}
	\caption{capturas de las salida del ejercicio 10}
	\label{fig:fig}
\end{figure}

En la figura 3.1 se muestra las lineas epipolares sobre las imágenes rectificadas
\subsection{Ejercicio 11}

A continuación el código que implementa el ejercicio 11:

\begin{lstlisting}
def localssd(img1, img2, K):
    """
        Calcula la matriz resultante donde cada punto es el valor SSD de img1 
        img2 sobre la ventana K
    :param img1: matriz con la primera imagen en grises
    :param img2: matriz con la segunda imagen en grises
    :param K: tamanio de la ventana cuadrada
    :return: matriz de SSD
    """
    # preparamos la matriz a la que hacer la convolucion, calculamos la matriz 
    # que cada punto sea (img1 - img2)^2
    salida = img1 - img2
    salida = salida * salida

    # hacemos la convolucion
    nucleo = np.zeros(K*K) + 1
    nucleo = nucleo.reshape(K, K)

    salida = ndimage.convolve(salida, nucleo)
    return salida
\end{lstlisting}

\subsection{Ejercicio 12}

A continuación el código que implementa el ejercicio 12:

\begin{lstlisting}
def desplazaImg(img, desp):
    """
        Desplaza una imagen tantas columnas como indique desp, rellenando las 
        columnas que queden vacias a 255. En la imagen desplazada la columna 
        num desp de img ahora estara en la posicion 0 de la nueva imagen .
    :param img: imagen a desplazar
    :param desp: entero menor que el numero de columnas de la imagen
    :return: imagen desplazada.
    """
    fila, col = img.shape
    nuevaImagen = np.zeros(fila*col) + 255
    nuevaImagen = nuevaImagen.reshape(fila, col)

    nuevaImagen[:, 0:(col - desp)] = img[:, desp:col]
    return nuevaImagen


def ssd_volume(im1, im2, disps, K):
    disparidades = len(disps)
    (filas, columnas) = im1.shape

    mapaDisparidad = np.zeros(disparidades*filas*columnas).reshape(disparidades, 
    															columnas, filas)
    for i in range(disparidades):
        imgDesplazada = desplazaImg(im2. disps[i])
        mapaDisparidad[i, :, :] = localssd(im1, imgDesplazada, K).transpose()
    return mapaDisparidad
\end{lstlisting}

\subsection{Ejercicio 13}

con la matriz de disparidades anterior, y usando la función argmin de numpy se puede calcular el vector de etiquetas como sigue:

\begin{lstlisting}
def ejercicio13(arrayDisparidades, disps):
    print("Ejecutando ejercio 13:")
    _, _, fil = arrayDisparidades.shape
    vector_etiquetas = np.zeros(fil)

    print("calculando el vector de distancias optimo:")
    vector_etiquetas = np.argmin(arrayDisparidades,  axis=0)
    vectorDistancias = disps[vector_etiquetas]

    ppl.imshow(vectorDistancias.transpose() * (255.0/vectorDistancias.flatten()
    							[np.argmax(vectorDistancias)]), cmap=cm.Greys_r)
    ppl.show()
\end{lstlisting} 

En la figura 3.2 se muestra la distancia de cada pixel. Cada distancia es un color, siendo negro para la distancia 0 y blanco para las distancia máxima. 

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{disparidad}
	\caption{capturas de las salida del ejercicio 13 para las imágenes de la figura 1.1-a}
	\label{fig:fig}
\end{figure}

\subsection{Ejercicio 14}

Código del procedimiento \textit{find\_corresp\_aexpansion} que utiliza la librería maxflow para minimizar la función de energía:

\begin{equation}
	E(x) = \sum_{i} D_i(x_i) + \sum_{ij} \lambda|x_i - x_j|
\end{equation}

\begin{lstlisting}
def find_corresp_aexpansion(D, initLabels, Lmb, maxV):
    """
        Minimiza la funcion de energia, penalizando el cambio de disparidad entre 
        dos vecinos, usando la funcion aexpansion de maxflow
    :param D: matriz de LxNxM donde L es el numero de disparidades que se contemplan,
    N el numero de columnas de las imagenes y M el numero de filas
    :param initLabels: valor inicial para las disparidades de los pixels
    :param Lmb: factor de suavizo float:[0,1]
    :param maxV: numero de indices de disparidad: int
    :return: matriz NxM, donde el campo i,j nos da la disparidad del pixel [y, x]
    """
    # inicializo dos matrices con los inidices, cruzados, de las disparidades
    # para calcular los costes de asociar dos disparidades cualesquiera 
    # a un pixel
    filas, cols = np.mgrid[:D.shape[-1], :D.shape[-1]]
    costesVecinos = np.float_(np.abs(filas - cols))

    # multiplico por el factor de suavizado lamda
    costesVecinos = costesVecinos * Lmb

    maxflow.fastmin.aexpansion_grid(D, costesVecinos, labels=initLabels, max_cycles=5)

    
def ejercicio14(img1, img2, disps, lamda):
    print("Ejecutando ejercio 14:")
    print ("calculando el mapa de disparidades...")
    arrayDisparidades = ejercicio12(img1, img2, disps)

    print("calculando el vector de distancias inicial...")
    vector_etiquetas = np.argmin(arrayDisparidades,  axis=0)
    # guardo una copia porque find_corresp_aexpansion sobreescribe vector_etiquetas
    vector_etiquetas_inicial = vector_etiquetas.copy()

    print("calculando el vector de distancias suavizado...")
    find_corresp_aexpansion(arrayDisparidades.transpose(), 
    vector_etiquetas.transpose(),lamda, len(disps))

    fig = ppl.figure()
    fig.add_subplot(1, 2, 1)
    ppl.imshow(vector_etiquetas_inicial, cmap=cm.Greys_r)
    fig.add_subplot(1, 2, 2)
    ppl.imshow(vector_etiquetas, cmap=cm.Greys_r)
    ppl.show()

\end{lstlisting}

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{disparidad_suave}
	\caption{izquierda antes del suavizado, derecha después}
	\label{fig:fig}
\end{figure}

En la figura 3.3 se muestra la salida del vector de disparidades antes y después del suavizado.

\subsection{Ejercicio 15}

Para ver la correspondencia de un punto de una imagen, sin rectificar, con su homologo en la otra imagen, sin rectificar. Primero habrá que pasar el punto seleccionado a las coordenadas de la imagen rectificada, que es para la que hemos calcula la correspondencia. Para ellos seguiremos la siguiente operación, donde H1 es la homografía que rectifica la imagen donde seleccionamos el punto:

\begin{equation}
	puntoRectificado = H1 * puntoSinRectificar
\end{equation}

Una vez tenemos el punto rectificado, podemos calcular su punto homologo usando la matriz de disparidades $S$, que calculamos en el ejercicio 14, de la siguiente forma:

\begin{equation}
	puntoRec = puntoRectificado
	punto2Rectifico = [puntoRec.x + S[puntoRec.y, puntoRec.x],puntoRec.y]
\end{equation}

Por último para pintar el punto en la segunda imagen sin rectificar, tendremos que pasarlo de nuevo a las coordenadas sin rectificar. Para ello seguiremos la siguiente fórmula:

\begin{equation}
	puntoSinRectifar = H2^{-1} * punto2Rectificado
\end{equation}

En la figura 3.4 se muestra la salida de la ejecución del ejercicio 15.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{correspondencias}
	\caption{izquierda puntos seleccionados, derecha puntos homólogos calculados}
	\label{fig:fig}
\end{figure}

%----------------------------------------------------------------------------------------

\end{document}